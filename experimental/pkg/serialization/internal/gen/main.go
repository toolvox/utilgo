package main

// import (
// 	"flag"
// 	"fmt"
// 	"go/format"
// 	"log"
// 	"os"
// 	"slices"
// 	"strings"

// 	"utilgo/pkg/tmplz"
// 	"utilgo/pkg/sliceutil"
// 	"utilgo/pkg/stringutil"
// )

// type opts struct {
// 	BasePath     string
// 	DoFormat     bool
// 	TagGenerated bool
// 	Debug        bool
// }

// func main() {
// 	var options opts
// 	flag.StringVar(&options.BasePath, "path", "../../", "Base path where files will be generated")
// 	flag.BoolVar(&options.DoFormat, "fmt", false, "Format generated code using go/format")
// 	flag.BoolVar(&options.TagGenerated, "tag", false, "Tag generated files with 'Code generated by' header")
// 	flag.BoolVar(&options.Debug, "debug", false, "debug mode")

// 	flag.Parse()

// 	if options.Debug {
// 		options.DoFormat = true
// 	}

// 	baseTemplates := tmplz.ParseTemplates(templateDefinitions)

// 	assignments := make(tmplz.Assignments)
// 	assignments.Assign("PathBase", options.BasePath)
// 	if options.TagGenerated {
// 		assignments["GeneratedCodeTag"] = "// Code generated by [internal/gen] DO NOT EDIT."
// 	} else {
// 		assignments["GeneratedCodeTag"] = ""
// 	}

// 	fileMatrix := sliceutil.Product(AllFormats, AllOperations)
// 	for _, fileRow := range fileMatrix {
// 		assignments := assignments.Clone()
// 		assignments.Assign("Format", fileRow[0])
// 		assignments.Assign("FormatLower", strings.ToLower(fileRow[0]))
// 		assignments.Assign("Operation", fileRow[1])
// 		assignments.Assign("OperationLower", strings.ToLower(fileRow[1]))

// 		imports := Imports{}
// 		imports.Sets[Go].Add("fmt", "os")
// 		switch fileRow[0] {
// 		case Json:
// 			imports.Sets[Go].Add("encoding/json")
// 		case Yaml:
// 			imports.Sets[External].Add("gopkg.in/yaml.v3")
// 		}

// 		possibleTargets := slices.Clone(InitialTargets)
// 		switch fileRow[1] {
// 		case Unmarshal:
// 			imports.Sets[Go].Add("io/fs")
// 			possibleTargets = append(possibleTargets, FS)
// 		case Decode:
// 			imports.Sets[Go].Add("io/fs", "io", "bytes")
// 			possibleTargets = append(possibleTargets, FS, Reader)
// 		case Encode:
// 			imports.Sets[Go].Add("bytes", "io")
// 			possibleTargets = append(possibleTargets, Writer)
// 		}

// 		funcBlocks := genFuncBlocks(baseTemplates, assignments, possibleTargets, &imports)

// 		imports.Assign(assignments)
// 		assignments.Assign("FuncBlocks", io.Indent(strings.Join(funcBlocks, "\n\t")))
// 		assignments = assignments.Clone()

// 		filePath, _ := baseTemplates.Execute("Path", assignments)
// 		fmt.Println("Path:", filePath)
// 		res, _ := baseTemplates.Execute("OperationFile", assignments)

// 		fmtRes, err := format.Source([]byte(res))
// 		if err != nil {
// 			log.Printf("Format Error: %v\n", err)
// 			fmtRes = []byte(res)
// 		}

// 		if err = os.WriteFile(filePath, fmtRes, 0644); err != nil {
// 			panic(err)
// 		}
// 	}
// }

// func genFuncBlocks(baseTemplates tmplz.MultiTemplate, assignments tmplz.Assignments, possibleTargets []string, imports *Imports) []string {
// 	funcBlocks := []string{}
// 	for _, target := range possibleTargets {
// 		assignments := assignments.Clone()
// 		assignments.Assign("Target", target)
// 		assignments.Assign("TargetName", target)
// 		if target == Mem {
// 			assignments.Assign("TargetName", "Mem")
// 		}

// 		options := OptionSet{Must}
// 		if assignments["Format"] == Json && (assignments["Operation"] == Encode || assignments["Operation"] == Marshal) {
// 			options = append(options, Indent)
// 		}
// 		if assignments["Operation"] == Decode || assignments["Operation"] == Unmarshal {
// 			options = append(options, Valid, Into)
// 		}

// 		if target == Reader || target == Writer {
// 			assignments.Assign("CommentTheProvided", "@CommentTheProvided@Target ")
// 		} else {
// 			assignments.Assign("CommentTheProvided", "")
// 		}

// 		if assignments["Operation"] == Encode {
// 			if target == Writer {
// 				assignments.Assign("BodyWriter", "")
// 			} else {
// 				assignments.Assign("BodyWriter", "writer := bytes.NewBuffer(data)")
// 			}
// 		}

// 		if target == File || target == FS {
// 			assignments.Assign("BlockLoadData", "@BlockLoad@Target_")
// 			if target == File {
// 				assignments.Assign("BlockSaveData", "@BlockSave@Target_")
// 			} else {
// 				assignments.Assign("BlockSaveData", "")
// 			}
// 		} else {
// 			assignments.Assign("BlockLoadData", "")
// 			assignments.Assign("BlockSaveData", "")
// 		}

// 		for _, optionSet := range sliceutil.PowerSet(options) {
// 			assignments := assignments.Clone()
// 			affixes := optionSet.Affixes()
// 			assignments.Assign("Prefix", affixes[Prefix].String())
// 			assignments.Assign("Infix", affixes[Infix].String())
// 			assignments.Assign("Suffix", affixes[Suffix].String())

// 			assignments.Assign("Return", "return")
// 			assignments.Assign("ErrorVar", "err error")
// 			assignments.Assign("CommentResultError", "or the error encountered")
// 			assignments.Assign("Must", "")
// 			if slices.Contains(optionSet, Must) {
// 				assignments.Assign("Return", "panic(err)")
// 				assignments.Assign("ErrorVar", "")
// 				assignments.Assign("CommentResultError", "or panics if an error is encountered")
// 				assignments.Assign("Must", "Must")
// 			}

// 			assignments.Assign("CommentUnmarshalResultAction", "Returns")
// 			assignments.Assign("CommentUnmarshalResultSuffix", "")
// 			assignments.Assign("Into", "")
// 			if slices.Contains(optionSet, Into) {
// 				assignments.Assign("CommentUnmarshalResultAction", "Assigns")
// 				assignments.Assign("CommentUnmarshalResultSuffix", "to the object pointer ")
// 				assignments.Assign("Into", "Into")

// 			}

// 			assignments.Assign("CommentIndent", "@CommentIndentFalse_")
// 			assignments.Assign("IndentOption", "")
// 			assignments.Assign("IndentArgs", "")
// 			if slices.Contains(optionSet, Indent) {
// 				assignments.Assign("CommentIndent", "@CommentIndentTrue_")
// 				assignments.Assign("IndentOption", "Indent")
// 				assignments.Assign("IndentArgs", ",\"\", \"\\t\"")
// 			}

// 			assignments.Assign("FuncGenericArg", "T any")
// 			assignments.Assign("CommentUnmarshalValid", "")
// 			assignments.Assign("CommentDecodeValid", "")
// 			assignments.Assign("BlockValidationMaybe", "")
// 			if slices.Contains(optionSet, Valid) {
// 				assignments.Assign("FuncGenericArg", "T errs.Validator")
// 				assignments.Assign("CommentUnmarshalValid", "@CommentValid")
// 				assignments.Assign("CommentDecodeValid", "@CommentValid")
// 				assignments.Assign("BlockValidationMaybe", "@BlockValidation_")
// 				imports.Sets[This].Add("utilgo/pkg/errs")
// 			}

// 			funcCode, err := baseTemplates.Execute("FuncCode", assignments.Clone())
// 			if err != nil {
// 				panic(err)
// 			}
// 			funcBlocks = append(funcBlocks, funcCode)
// 		}
// 	}
// 	return funcBlocks
// }

// var io = stringutil.IndentOption{stringutil.EmptyLine_TrimAll, "\t", "\t"}

// var templateDefinitions = map[string]string{
// 	"Path":     "@PathBase_@FormatLower/zz_@OperationLower.go",
// 	"FuncName": "@Prefix_@Operation_@Infix_@Target_@Suffix",

// 	"FuncCode": io.Indent(`
// 		@Comment@Operation 
// 		@Comment@Operation_Extra
// 		@Comment@Operation_Result
// 		func @FuncName[@FuncGenericArg](@FuncArgs@Operation_@Into) (@FuncRets@Operation_@Into) { 
// 			@FuncBody@Operation_ 
// 			return
// 		}
// 	`),

// 	"TestFuncCode": io.Indent(`
// 		func Test_@FuncName(t *testing.T) {
// 			t.Fail()
// 		}
// 	`),

// 	"OperationFile": io.Indent(`
// 	package @FormatLower

// 	@GeneratedCodeTag
	
// 	import ( 
// 		@ImportsGo 
// 		@ImportsExternal 
// 		@ImportsThis
// 	)
	
// 	@FuncBlocks
// 	`),

// 	"CommentUnmarshal": `// @FuncName parses the object encoded in the provided @FormatLower @CommentTarget@TargetName_.`,
// 	"CommentMarshal":   `// @FuncName encodes the object to a@CommentIndent @FormatLower @CommentTarget@TargetName_.`,
// 	"CommentDecode":    `// @FuncName uses [@FormatLower.@Operation_r] @CommentTheProvided_to @OperationLower the object encoded in the @FormatLower @CommentTarget@TargetName_.`,
// 	"CommentEncode":    `// @FuncName uses [@FormatLower.@Operation_r] @CommentTheProvided_to @OperationLower the object to a@CommentIndent @FormatLower @CommentTarget@TargetName_.`,

// 	"CommentUnmarshalResult": `// @CommentUnmarshalResultAction the decoded object @CommentUnmarshalResultSuffix_@CommentResultError_.`,
// 	"CommentMarshalResult":   `// @CommentMarshalResultAction@TargetName the encoded @FormatLower @CommentTarget@TargetName_ @CommentResultError_.`,
// 	"CommentDecodeResult":    `// @CommentUnmarshalResultAction the decoded object @CommentUnmarshalResultSuffix_@CommentResultError_.`,
// 	"CommentEncodeResult":    `// @CommentMarshalResultAction@TargetName the encoded @FormatLower @CommentTarget@TargetName_ @CommentResultError_.`,

// 	"CommentMarshalResultActionFile":   "Saves",
// 	"CommentMarshalResultActionMem":    "Returns",
// 	"CommentMarshalResultActionWriter": "Writes",

// 	"CommentTheProvidedReader": "with the provided [io.reader]",
// 	"CommentTheProvidedWriter": "with the provided [io.writer]",
// 	"CommentTheProvidedNone":   "",

// 	"CommentIndentTrue":  "n indented",
// 	"CommentIndentFalse": "",

// 	"CommentTargetMem":    "byte slice",
// 	"CommentTargetFile":   "file",
// 	"CommentTargetFS":     "file from the provided FS",
// 	"CommentTargetReader": "data read by the reader",
// 	"CommentTargetWriter": "writer's data",

// 	"CommentUnmarshalExtra": "@CommentUnmarshalValid",
// 	"CommentMarshalExtra":   "",
// 	"CommentDecodeExtra":    "@CommentDecodeValid",
// 	"CommentEncodeExtra":    "",

// 	"CommentValid": "// Expects the decoded type to implement [pkg/utilgo/pkg/errs.Validator] and treats validation errors as decoding errors.",

// 	"BodyReader": "reader := bytes.NewReader(data)",
// 	"BodyWriter": "writer := bytes.NewBuffer(data)",

// 	"FuncUnmarshalResult":     "obj T",
// 	"FuncArgsUnmarshalMem":    "data []byte",
// 	"FuncArgsUnmarshalFile":   "path string",
// 	"FuncArgsUnmarshalFS":     "path string, f fs.FS",
// 	"FuncArgsUnmarshalReader": "reader io.Reader",
// 	"FuncMarshalResultMem":    "data []byte,",
// 	"FuncMarshalResultFile":   "",
// 	"FuncMarshalResultWriter": "",
// 	"FuncArgsMarshalMem":      "obj T",
// 	"FuncArgsMarshalFile":     "obj T, path string",
// 	"FuncArgsMarshalWriter":   "obj T, writer io.Writer",

// 	"FuncArgsEncode": "@FuncArgsMarshal",
// 	"FuncArgsDecode": "@FuncArgsUnmarshal",

// 	"FuncArgsDecodeReader": "",
// 	"FuncArgsDecodeWriter": "",

// 	"FuncArgsUnmarshal": "@FuncArgsUnmarshal@TargetName",
// 	"FuncRetsUnmarshal": "@FuncUnmarshalResult, @ErrorVar",
// 	"FuncArgsMarshal":   "@FuncArgsMarshal@TargetName",
// 	"FuncRetsMarshal":   "@FuncMarshalResult@TargetName @ErrorVar",
// 	"FuncRetsEncode":    "@FuncRetsMarshal_",
// 	"FuncRetsDecode":    "@FuncRetsUnmarshal_",

// 	"FuncArgsUnmarshalInto": "@FuncArgsUnmarshal@TargetName, @FuncUnmarshalResult",
// 	"FuncRetsUnmarshalInto": "@ErrorVar",
// 	"FuncArgsDecodeInto":    "@FuncArgsUnmarshal@TargetName, @FuncUnmarshalResult",
// 	"FuncRetsDecodeInto":    "@ErrorVar",

// 	"ErrorDefMust":     "var err error",
// 	"ErrorDef":         "",
// 	"DataDefFile":      "var data []byte",
// 	"DataDefMem":       "",
// 	"BodyWriterWriter": "",
// 	"BodyReaderReader": "",

// 	"FuncBodyUnmarshal": io.Indent(`
// 		@ErrorDef@Must_ 
// 		@BlockLoadData_
// 		if err = @FormatLower_.Unmarshal@IndentOption_(data, &obj); err != nil {
// 			err = fmt.Errorf("unmarshal @FormatLower_: %w", err)
// 			@Return_
// 		}
// 		@BlockValidationMaybe_`),

// 	"FuncBodyMarshal": io.Indent(`
// 		@ErrorDef@Must_ 
// 		@DataDef@TargetName_
// 		data, err = @FormatLower_.Marshal@IndentOption_(obj@IndentArgs_)
// 		if err != nil {
// 			err = fmt.Errorf("marshal @FormatLower_: %w", err)
// 			@Return_
// 		}
// 		@BlockSaveData_`),

// 	"FuncBodyDecode": io.Indent(`
// 		@ErrorDef@Must_ 
// 		@BodyReader@Target_
// 		decoder := @FormatLower_.NewDecoder(reader)
// 		err = decoder.Decode(&obj)
// 		if err != nil {
// 			err = fmt.Errorf("decode @FormatLower_: %w", err)
// 			@Return_
// 		}
// 		@BlockValidationMaybe_`),

// 	"FuncBodyEncode": io.Indent(`
// 		@ErrorDef@Must_ 
// 		@BodyWriter@Target_
// 		encoder := @FormatLower_.NewEncoder(writer)
// 		@BlockEncoder@IndentOption_
// 		err = encoder.Encode(obj)
// 		if err != nil {
// 			err = fmt.Errorf("encode @FormatLower_: %w", err)
// 			@Return_
// 		}
// 		`),

// 	"BlockValidation": io.Indent(`
// 		if err = obj.Validate(); err != nil {
// 			err = fmt.Errorf("validation: %w", err)
// 			@Return_
// 		}
// 	`),
// 	"BlockEncoder": "",
// 	"BlockEncoderIndent": io.Indent(`
// 		encoder.SetIndent("","\t")
// 	`),

// 	"BlockSaveFile": io.Indent(`
// 		err = os.WriteFile(path, data, 0644)
// 		if err != nil {
// 			err = fmt.Errorf("write file '%s': %w", path, err)
// 			@Return_
// 		}
// 	`),

// 	"BlockLoadFile": io.Indent(`
// 		data, err := os.ReadFile(path)
// 		if err != nil {
// 			err = fmt.Errorf("read file '%s': %w", path, err)
// 			@Return_
// 		}	
// 	`),

// 	"BlockLoadFS": io.Indent(`
// 		data, err := fs.ReadFile(f, path)
// 		if err != nil {
// 			err = fmt.Errorf("read file '%s': %w", path, err)
// 			@Return_
// 		}
// 	`),

// 	"BodyWriterFile": io.Indent(`
// 		writer, err := os.OpenFile(path, os.O_CREATE|os.O_TRUNC, 0644)
// 		if err != nil {
// 			err = fmt.Errorf("open file: %w", err)
// 			@Return_
// 		}
// 		defer writer.Close()
// 	`),

// 	"BodyReaderFile": io.Indent(`
// 		reader, err := os.Open(path)
// 		if err != nil {
// 			err = fmt.Errorf("open file: %w", err)
// 			@Return_
// 		}
// 		defer reader.Close()
// 	`),

// 	"BodyReaderFS": io.Indent(`
// 		reader, err := f.Open(path)
// 		if err != nil {
// 			err = fmt.Errorf("open fs file: %w", err)
// 			@Return_
// 		}
// 		defer reader.Close()
// 	`),
// }
